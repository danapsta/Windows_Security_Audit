# Comprehensive Security Audit Script
# Combines GPO auditing, computer-specific checks, and account information reporting

# Import required modules
Import-Module ActiveDirectory
Import-Module GroupPolicy

# Create the output directory if it doesn't exist
$OutputDir = "C:\Temp"
$OutputFile = "$OutputDir\Security_Audit_Report.txt"
if (!(Test-Path -Path $OutputDir)) { 
    New-Item -ItemType Directory -Path $OutputDir | Out-Null 
}

# Function to write to both console and log file
function Write-OutputLog {
    param (
        [string]$Message,
        [string]$Section = "",
        [switch]$IsHeading = $false
    )
    
    if ($IsHeading) {
        $separator = "=" * 75
        Write-Host "`n$separator" -ForegroundColor Cyan
        Write-Host $Message -ForegroundColor Cyan
        Write-Host "$separator" -ForegroundColor Cyan
        
        "`n$separator" | Out-File -FilePath $OutputFile -Append
        $Message | Out-File -FilePath $OutputFile -Append
        "$separator" | Out-File -FilePath $OutputFile -Append
    }
    elseif ($Section -ne "") {
        Write-Host "`n----- $Section -----" -ForegroundColor Yellow
        Write-Host $Message
        
        "`n----- $Section -----" | Out-File -FilePath $OutputFile -Append
        $Message | Out-File -FilePath $OutputFile -Append
    }
    else {
        Write-Host $Message
        $Message | Out-File -FilePath $OutputFile -Append
    }
}

# Function to check GPOs for specific settings
function Find-GPOSettings {
    param (
        [string[]]$SearchTerms,
        [string]$SettingName
    )

    Write-OutputLog -Section "$SettingName GPO Settings" -Message "Checking for GPOs that affect $SettingName..."
    
    $FoundSettings = @()
    $AllGPOs = Get-GPO -All

    foreach ($GPO in $AllGPOs) {
        $GPOReport = Get-GPOReport -Guid $GPO.Id -ReportType XML
        
        foreach ($Term in $SearchTerms) {
            if ($GPOReport -match $Term) {
                $FoundSettings += "GPO '$($GPO.DisplayName)' (ID: $($GPO.Id)) may affect $SettingName"
                break
            }
        }
    }

    if ($FoundSettings.Count -eq 0) {
        Write-OutputLog -Message "No Group Policy configured for $SettingName."
    }
    else {
        Write-OutputLog -Message ($FoundSettings -join "`n")
    }
}

# Function to check settings on specific computers
function Check-ComputerSettings {
    param (
        [string]$SettingName,
        [scriptblock]$CheckScript
    )

    Write-OutputLog -Section "$SettingName Status on Domain Computers" -Message "Checking $SettingName on individual domain computers..."
    
    $Computers = Get-ADComputer -Filter * | Select-Object -ExpandProperty Name
    $Results = @()

    foreach ($Computer in $Computers) {
        try {
            $Result = Invoke-Command -ComputerName $Computer -ScriptBlock $CheckScript -ErrorAction Stop
            $Results += "$Computer : $SettingName - $Result"
        }
        catch {
            $Results += "$Computer : Error retrieving $SettingName status"
        }
    }

    Write-OutputLog -Message ($Results -join "`n")
}

# Initialize the report
"Security Audit Results - $(Get-Date)" | Out-File -FilePath $OutputFile -Force
"Generated by: $($env:USERNAME)" | Out-File -FilePath $OutputFile -Append
"Computer: $($env:COMPUTERNAME)" | Out-File -FilePath $OutputFile -Append
"Domain: $((Get-WmiObject Win32_ComputerSystem).Domain)" | Out-File -FilePath $OutputFile -Append
"=" * 75 | Out-File -FilePath $OutputFile -Append

# Start audit
Write-OutputLog -Message "Starting Security Audit" -IsHeading $true
Write-OutputLog -Message "Script executed on: $(Get-Date)"
Write-OutputLog -Message "Computer: $($env:COMPUTERNAME)"
Write-OutputLog -Message "Domain: $((Get-WmiObject Win32_ComputerSystem).Domain)"
Write-OutputLog -Message "User: $($env:USERNAME)"

# Ask if user wants to run checks on all domain computers
$CheckAllComputers = Read-Host "Do you want to run checks against ALL domain computers? (y/n) (This may take a long time)"

# 1. SMB Version 1 Status
Write-OutputLog -Message "SMB Version 1 Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("SMB1", "SMBv1", "LanmanServer", "SMBServer") -SettingName "SMB Version 1"

if ($CheckAllComputers -eq "y") {
    $SMBv1CheckScript = {
        try {
            $SMBConfig = Get-SmbServerConfiguration -ErrorAction Stop
            return "Enabled - $($SMBConfig.EnableSMB1Protocol)"
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "SMBv1 Status" -CheckScript $SMBv1CheckScript
}

# 2. SMB Signing Status
Write-OutputLog -Message "SMB Signing Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("RequireSecuritySignature", "EnableSecuritySignature", "LanmanServer", "LanmanWorkstation") -SettingName "SMB Signing"

if ($CheckAllComputers -eq "y") {
    $SMBSigningCheckScript = {
        try {
            $Signing = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters" -Name "RequireSecuritySignature" -ErrorAction SilentlyContinue
            return "Required - $($Signing.RequireSecuritySignature)"
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "SMB Signing Required" -CheckScript $SMBSigningCheckScript
}

# 3. LLMNR Status
Write-OutputLog -Message "LLMNR Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("DNSClient", "EnableMulticast", "LLMNR", "Link-Local") -SettingName "LLMNR"

if ($CheckAllComputers -eq "y") {
    $LLMNRCheckScript = {
        try {
            $LLMNR = Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient" -Name "EnableMulticast" -ErrorAction SilentlyContinue
            if ($LLMNR) {
                return "Enabled - $($LLMNR.EnableMulticast)"
            }
            else {
                return "Not explicitly configured (defaults to enabled)"
            }
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "LLMNR Status" -CheckScript $LLMNRCheckScript
}

# 4. NetBIOS Status
Write-OutputLog -Message "NetBIOS Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("NetBIOS", "NetBT", "NetbiosOptions") -SettingName "NetBIOS"

if ($CheckAllComputers -eq "y") {
    $NetBIOSCheckScript = {
        try {
            $NetBIOS = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\Interfaces\Tcpip_*" -Name "NetbiosOptions" -ErrorAction SilentlyContinue
            return "Status - $($NetBIOS.NetbiosOptions)"
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "NetBIOS Status" -CheckScript $NetBIOSCheckScript
}

# 5. NTLMv1 Status
Write-OutputLog -Message "NTLMv1 Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("LmCompatibilityLevel", "NtlmMinClientSec", "NTLM", "Lsa") -SettingName "NTLMv1"

if ($CheckAllComputers -eq "y") {
    $NTLMv1CheckScript = {
        try {
            $NTLMv1 = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name "LmCompatibilityLevel" -ErrorAction SilentlyContinue
            if ($NTLMv1) {
                $description = switch ($NTLMv1.LmCompatibilityLevel) {
                    0 { "Send LM and NTLM responses (lowest security)" }
                    1 { "Send LM and NTLM - use NTLMv2 session security if negotiated" }
                    2 { "Send NTLM response only" }
                    3 { "Send NTLMv2 response only" }
                    4 { "Send NTLMv2 response only, refuse LM" }
                    5 { "Send NTLMv2 response only, refuse LM and NTLM (highest security)" }
                    default { "Unknown" }
                }
                return "Level $($NTLMv1.LmCompatibilityLevel) - $description"
            }
            else {
                return "Not explicitly configured"
            }
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "NTLMv1 Status" -CheckScript $NTLMv1CheckScript
}

# 6. Legacy Transport Security
Write-OutputLog -Message "Legacy Transport Security Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("SCHANNEL", "TLS", "SSL", "Protocols", "Cipher") -SettingName "Transport Security"

if ($CheckAllComputers -eq "y") {
    $TLSCheckScript = {
        try {
            $protocols = @("SSL 2.0", "SSL 3.0", "TLS 1.0", "TLS 1.1", "TLS 1.2")
            $results = @()
            
            foreach ($protocol in $protocols) {
                $clientPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\$protocol\Client"
                $serverPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\$protocol\Server"
                
                if (Test-Path $clientPath) {
                    $clientValue = Get-ItemProperty -Path $clientPath -Name "Enabled" -ErrorAction SilentlyContinue
                    if ($clientValue) {
                        $results += "$protocol Client: $($clientValue.Enabled)"
                    }
                }
                
                if (Test-Path $serverPath) {
                    $serverValue = Get-ItemProperty -Path $serverPath -Name "Enabled" -ErrorAction SilentlyContinue
                    if ($serverValue) {
                        $results += "$protocol Server: $($serverValue.Enabled)"
                    }
                }
            }
            
            return ($results -join ", ")
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "TLS/SSL Status" -CheckScript $TLSCheckScript
}

# 7. Windows Firewall Status
Write-OutputLog -Message "Windows Firewall Status" -IsHeading $true
Find-GPOSettings -SearchTerms @("WindowsFirewall", "Firewall", "EnableFirewall") -SettingName "Windows Firewall"

if ($CheckAllComputers -eq "y") {
    $FirewallCheckScript = {
        try {
            $FirewallStatus = Get-NetFirewallProfile | Select-Object Name, Enabled
            return "Status - $($FirewallStatus.Name): $($FirewallStatus.Enabled)"
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "Windows Firewall" -CheckScript $FirewallCheckScript
}

# 8. Password Policy
Write-OutputLog -Message "Password Policy" -IsHeading $true
$PasswordPolicy = Get-ADDefaultDomainPasswordPolicy
$PasswordPolicyOutput = @"
Minimum Password Length: $($PasswordPolicy.MinPasswordLength)
Password Complexity: $($PasswordPolicy.ComplexityEnabled)
Minimum Password Age: $($PasswordPolicy.MinPasswordAge.Days) days
Maximum Password Age: $($PasswordPolicy.MaxPasswordAge.Days) days
Password History: $($PasswordPolicy.PasswordHistoryCount) passwords remembered
Reversible Encryption: $($PasswordPolicy.ReversibleEncryptionEnabled)
"@
Write-OutputLog -Section "Password Policy Configuration" -Message $PasswordPolicyOutput

# 9. Account Lockout Policy
Write-OutputLog -Message "Account Lockout Policy" -IsHeading $true
$LockoutPolicyOutput = @"
Lockout Threshold: $($PasswordPolicy.LockoutThreshold) invalid login attempts
Lockout Duration: $($PasswordPolicy.LockoutDuration.TotalMinutes) minutes
Lockout Observation Window: $($PasswordPolicy.LockoutObservationWindow.TotalMinutes) minutes
"@
Write-OutputLog -Section "Account Lockout Configuration" -Message $LockoutPolicyOutput

# 10. Screen Lock Policy
Write-OutputLog -Message "Screen Lock Policy" -IsHeading $true
Find-GPOSettings -SearchTerms @("ScreenSave", "Screen saver", "Timeout", "InactivityTimeout", "ScreenSaveTimeOut", "ScreenSaveActive") -SettingName "Screen Lock"

# 11. Administrative Accounts
Write-OutputLog -Message "Administrative Accounts" -IsHeading $true

# Domain Admins
$DomainAdmins = Get-ADGroupMember -Identity "Domain Admins" -Recursive | ForEach-Object {
    Get-ADUser -Identity $_.SamAccountName -Properties Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires |
    Select-Object SamAccountName, Name, Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires
}
$DomainAdminsOutput = $DomainAdmins | Format-Table -AutoSize | Out-String
Write-OutputLog -Section "Domain Admins Group Members" -Message $DomainAdminsOutput

# Enterprise Admins
try {
    $EnterpriseAdmins = Get-ADGroupMember -Identity "Enterprise Admins" -Recursive -ErrorAction SilentlyContinue | ForEach-Object {
        Get-ADUser -Identity $_.SamAccountName -Properties Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires |
        Select-Object SamAccountName, Name, Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires
    }
    $EnterpriseAdminsOutput = $EnterpriseAdmins | Format-Table -AutoSize | Out-String
    Write-OutputLog -Section "Enterprise Admins Group Members" -Message $EnterpriseAdminsOutput
} catch {
    Write-OutputLog -Section "Enterprise Admins Group Members" -Message "Unable to retrieve Enterprise Admins or group does not exist."
}

# Administrators
try {
    $Administrators = Get-ADGroupMember -Identity "Administrators" -Recursive -ErrorAction SilentlyContinue | Where-Object {$_.objectClass -eq "user"} | ForEach-Object {
        Get-ADUser -Identity $_.SamAccountName -Properties Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires |
        Select-Object SamAccountName, Name, Enabled, LastLogonDate, PasswordLastSet, PasswordNeverExpires
    }
    $AdministratorsOutput = $Administrators | Format-Table -AutoSize | Out-String
    Write-OutputLog -Section "Administrators Group Members" -Message $AdministratorsOutput
} catch {
    Write-OutputLog -Section "Administrators Group Members" -Message "Unable to retrieve Administrators or group does not exist."
}

# 12. Shared Accounts
Write-OutputLog -Message "Potential Shared Accounts" -IsHeading $true
$SharedAccounts = Get-ADUser -Filter {(SamAccountName -like "*nurse*") -or (SamAccountName -like "*admin*") -or 
                                      (SamAccountName -like "*service*") -or (SamAccountName -like "*shared*") -or 
                                      (SamAccountName -like "*dept*") -or (SamAccountName -like "*team*")} -Properties Description, Enabled, LastLogonDate, PasswordLastSet |
                  Select-Object SamAccountName, Name, Description, Enabled, LastLogonDate, PasswordLastSet

$SharedAccountsOutput = $SharedAccounts | Format-Table -AutoSize | Out-String
Write-OutputLog -Section "Potential Shared Accounts" -Message $SharedAccountsOutput

# 13. Inactive Accounts
Write-OutputLog -Message "Inactive Accounts (>90 days)" -IsHeading $true
$CutoffDate = (Get-Date).AddDays(-90)

$InactiveUsers = Get-ADUser -Filter {LastLogonDate -lt $CutoffDate -and Enabled -eq $true} -Properties LastLogonDate |
                Select-Object SamAccountName, Name, LastLogonDate, DistinguishedName

$InactiveUsersOutput = $InactiveUsers | Format-Table -AutoSize | Out-String
Write-OutputLog -Section "Inactive User Accounts" -Message $InactiveUsersOutput

$InactiveComputers = Get-ADComputer -Filter {LastLogonDate -lt $CutoffDate -and Enabled -eq $true} -Properties LastLogonDate, OperatingSystem |
                    Select-Object Name, OperatingSystem, LastLogonDate, DistinguishedName

$InactiveComputersOutput = $InactiveComputers | Format-Table -AutoSize | Out-String
Write-OutputLog -Section "Inactive Computer Accounts" -Message $InactiveComputersOutput

# 14. Non-Expiring Passwords
Write-OutputLog -Message "Accounts with Non-Expiring Passwords" -IsHeading $true
$NonExpiringUsers = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} -Properties PasswordNeverExpires, PasswordLastSet, LastLogonDate, Description |
                    Select-Object SamAccountName, Name, Description, PasswordLastSet, LastLogonDate

$NonExpiringUsersOutput = $NonExpiringUsers | Format-Table -AutoSize | Out-String
Write-OutputLog -Section "Accounts with Non-Expiring Passwords" -Message $NonExpiringUsersOutput

# 15. Local Admin Rights
Write-OutputLog -Message "Local Admin Rights" -IsHeading $true

if ($CheckAllComputers -eq "y") {
    $LocalAdminCheckScript = {
        try {
            $computerName = $env:COMPUTERNAME
            $localAdminGroup = [ADSI]"WinNT://$computerName/Administrators"
            $members = @($localAdminGroup.Invoke("Members"))
            
            $adminMembers = @()
            foreach ($member in $members) {
                $memberName = $member.GetType().InvokeMember("Name", "GetProperty", $null, $member, $null)
                $adminMembers += $memberName
            }
            
            return "Local Admins - $($adminMembers -join ' ')"
        }
        catch {
            return "Unable to retrieve configuration"
        }
    }
    Check-ComputerSettings -SettingName "Local Administrators" -CheckScript $LocalAdminCheckScript
}
else {
    Write-OutputLog -Section "Local Admin Rights" -Message "This check requires running against individual computers. Use the 'y' option at the start to perform this check."
}

# 16. Outdated OS
Write-OutputLog -Message "Out-of-Support Operating Systems" -IsHeading $true

if ($CheckAllComputers -eq "y") {
    $OSCheckScript = {
        try {
            (Get-WmiObject Win32_OperatingSystem).Caption
        }
        catch {
            return "Unable to retrieve OS information"
        }
    }
    Check-ComputerSettings -SettingName "OS" -CheckScript $OSCheckScript
}
else {
    # Check for outdated OS without connecting to each computer
    $outdatedOS = Get-ADComputer -Filter {Enabled -eq $true} -Properties OperatingSystem, OperatingSystemVersion |
    Where-Object {
        $os = $_.OperatingSystem
        if ($os -like "*Windows 7*" -or 
            $os -like "*Windows XP*" -or 
            $os -like "*Server 2003*" -or 
            $os -like "*Server 2008*" -or 
            $os -like "*Server 2012*" -or 
            ($os -like "*Windows 8*" -and $os -notlike "*Windows 8.1*")) {
            return $true
        }
        return $false
    } | Select-Object Name, OperatingSystem, OperatingSystemVersion

    if ($outdatedOS.Count -gt 0) {
        $outdatedOSOutput = $outdatedOS | Format-Table -AutoSize | Out-String
        Write-OutputLog -Section "Out-of-Support Operating Systems" -Message $outdatedOSOutput
    }
    else {
        Write-OutputLog -Section "Out-of-Support Operating Systems" -Message "No out-of-support operating systems detected based on AD information."
    }
}

# Finish
Write-OutputLog -Message "Security Audit Complete" -IsHeading $true
Write-OutputLog -Message "The security audit has been completed. Results have been saved to: $OutputFile"

Write-Host "`nScript execution completed." -ForegroundColor Green